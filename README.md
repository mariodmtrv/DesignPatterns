DesignPatterns
==============

Nothing to see here. Just my design patterns training stubs

<h2> Implemented patterns </h2>
<ul>
  <li>
    <h3>Strategy</h3>
    <p>
      Defines a family of algorithms,
      encapsulates each one, and makes them interchangeable.
      Strategy lets the algorithm vary independently from clients that use it
    </p>
  </li>
  <li>
    <h3> Observer </h3>
    <p>
      Defines a one-to-many dependency so that when a subject 
      changes state all its dependent observers are notified
    </p>
    
  </li>
  <li>
    <h3> Decorator </h3>
    <p>
      Assigns additional responsibility to objects dynamically.
      A flexible alternative to subclassing for extending functionality
    </p>
  </li>
<li>
    <h3> Factory </h3>
    <p>
       Defines an interface for creating an object, 
       but lets the subclasses decide which class to instantiate.
       Lets a class defer instantiation to subclasses
    </p>
  </li>
<li>
    <h3> Singleton </h3>
    <p>
       Ensures a class has only one instance and 
       provides a global point of access to it
    </p>
</li>
<li>
    <h3> Command </h3>
    <p>
       Encapsulates a request as an object, thereby letting parameterization of other objects with different requests, queue or log requests, and support undoable operations
    </p>
</li>
<li>
    <h3> Adapter </h3>
    <p>
      Converts the interface of a class into another interface the client expects. Adapter lets classes work together that couldn't otherwise because of incopatible interfaces.
    </p>
</li>
</ul>
